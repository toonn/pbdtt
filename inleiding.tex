\chapter{Inleiding}
\label{inleiding}

In deze thesis worden twee programmeertalen met een sterk typesysteem
vergeleken. Dit met een nadruk op het typesysteem van de talen eerder dan de
talen zelf. Het gaat hier om twee functionele programmeertalen: Agda
\ref{agda}, een dependently typed programmeertaal, en Haskell \ref{haskell},
een taal met een Hindley-Milner \ref{hindmil} typesysteem.


\section{Typesystemen}

Een typesysteem is een verzameling van regels waaraan code in een bepaalde
programmeertaal moet voldoen. Er zijn verschillende redenen om zulke regels op
te leggen. De belangrijkste is type safety; dit betekent dat de computer nooit
onzinnige bewerkingen zal uitvoeren, wat een onzinnige bewerking juist is,
hangt af van het typesysteem. Gewoonlijk worden bewerking zoals optelling enkel
gedefinieerd op getallen, een voorbeeld van een onzinnige bewerking zou dan een
optelling kunnen zijn van een getal en een lijst. Een andere vorm van
bescherming die onder type safety valt is memory safety. Een belangrijke vorm
hiervan is bescherming tegen buffer overflows, deze hebben vaak security
vulnerabilities tot gevolg maar als het typesysteem over genoeg informatie
beschikt, kan gegarandeerd worden dat ze niet kunnen voorkomen.
Een andere reden voor een typesysteem is bijvoorbeeld optimalisatie: als de
compiler meer informatie heeft kunnen er soms betere optimalisaties gedaan
worden. Types kunnen ook een vorm van documentatie zijn: een typesynoniem kan
bijvoorbeeld verduidelijken dat een functie een naam verwacht in plaats van een
gewoon een string, wat het type is voor een opeenvolging van karakters.

Er is een grote variatie aan bestaande typesystemen. Het typesysteem voor de
programmeertaal C \ref{C}, heeft eenvoudige types die in direct verband staan
met de voorstelling van de bijhorende waarden op het niveau van bits en bytes.
Het typesysteem van Java \ref{Java} daarentegen is volledig gericht op de
objectgeoriënteerde metafoor: een object wordt gedefinieerd door een klasse en
die klasse \emph{is} tevens het type voor dat object. Het Hindley-Milner
typesysteem wordt vaak gebruikt als basis voor het typesysteem van functionele
programmeertalen. Het meest merkwaardige kenmerk van dit typesysteem is dat het
meest algemene type voor een waarde altijd geïnfereert kan worden. Het
resultaat hiervan is dat een programma geschreven kan worden zonder enige type
annotatie en het typesysteem toch kan garanderen dat type safety behouden
blijft. Het typesysteem van Haskell is gebaseerd op het Hindley-Milner
typesysteem maar heeft een groot aantal uitbreidingen hierop. Zulke
uitbreidingen maken het typesysteem expressiever.


\section{Dependent Types}

Dependent types zijn nauw verbonden met de Curry-Howard correspondence
\ref{curryhow}. Ze breiden het verband tussen types en propositielogica uit tot
een predicatenlogica door het mogelijk te maken om de logische kwantoren voor
te stellen. Het verschil met andere typesystemen is dat dependent types kunnen
afhangen van waarden, zo kan het type van een lijst afhangen van de lengte
ervan. Deze op het eerste zicht kleine verandering heeft een grote impact op de
expressiviteit van het typesysteem. Plotseling wordt het mogelijk om ontzettend
veel eigenschappen van de code op te nemen in de types waardoor ze statisch
gegarandeerd worden. Schendingen van de eigenschappen die we gecodeerd hebben
in de types zijn dus schendingen van de type safety en het typesysteem laat
zulke programma's niet toe.

De eigenschappen die we opnemen in de types gaan van heel eenvoudig,
bijvoorbeeld de lengte van een lijst, tot eerder ingewikkeld, bijvoorbeeld
invarianten van zoekbomen. Fundamenteel is er geen limiet, wat in logica uit te
drukken is, is ook in de types uit te drukken. Echter als we ons bezig houden
met programmeren eerder dan bewijzen formaliseren zijn de eigenschappen die we
wensen af te dwingen vaak eerder eenvoudig. We gebruiken de types eerder om
eigenschappen die we in talen zonder dependent types impliciet laten en dus in
het achterhoofd moeten houden, expliciet te maken en zo door het typesysteem
laten nakijken.

De typentheorie waarop Agda gebaseerd is, gelijkt op de intuïtionistische
typentheorie van Per Martin-Löf \ref{martinlof}. In deze thesis laten we dit
terzijde en bekijken we Agda als een programmeertaal met dependent types in
tegenstelling to Haskell, wat als voorbeeld dient voor een programmeertaal die
in de praktijk toegepast wordt voor grootschalige systemen. Deze veralgemening
schiet natuurlijk tekort, Agda is geen perfecte voorstelling van \emph{alle}
programmeertalen met dependent types en Haskell is niet de enige
programmeertaal die die op industriële schaal gebruikt kan worden met een sterk
typesysteem.

Het volgende voorbeeld wordt vaak gebruikt om het concept van dependent types
te illustreren. Deze code komt uit de Agda Standard Library \ref{agda:stdlib}
maar is licht aangepast om het voorbeeld eenvoudiger te maken.

%----------------------------------------%
\begin{minted}[fontsize=\small]{agda}
  data Vec (A : Set) : ℕ → Set where
    []  : Vec A zero
    _∷_ : ∀ {n} (x : A) (xs : Vec A n) → Vec A (suc n)

  head : ∀ {n} {A : Set} → Vec A (suc n) → A
  head (x ∷ xs) = x
\end{minted}

TODO Deze code is waarschijnlijk nog te cryptisch voor iemand die nog nooit
Agda heeft gezien, ofwel moet het meer gedetailleerd uitgelegd worden hier
ofwel moet het voorbeeld pas in een later hoofdstuk behandeld worden.
\iagda{Vec} is het type voor lijsten met een vaste lengte. De lege lijst,
\iagda{[]}, heeft lengte nul, het type is \iagda{Vec A zero}: het is dus een
\iagda{Vec} van elementen van type \iagda{A} met lengte \iagda{zero}. De
constructor die langere lijsten maakt, verwacht een element, \iagda{x} van type
\iagda{A}, een lijst met elementen van hetzelfde type \iagda{A} van een
bepaalde lengte \iagda{n}, \iagda{xs} met als type \iagda{Vec A n}, en geeft
een lijst terug waarvan de lengte één groter is. De \iagda{head} functie, die
het eerste element van een lijst terug geeft kan dan eisen dat ze enkel werkt
op lijsten met een lengte groter dan nul, lijsten met type
\iagda{Vec A (suc n)}. Als de lengte niet in het type opgenomen is, kan een
functie er ook geen voorwaarden aan opleggen. Zo moet de \ihask{head} functie
voor gewone lijsten uit Haskell een fout opwerpen wanneer ze opgeroepen wordt
met een lege lijst als argument. Dit is een heel eenvoudig voorbeeld en hieruit
blijkt niet welke van de twee een betere manier is om lijsten voor te stellen.
Het laat wel zien wat het betekent voor een type om af te hangen van een waarde.

Een tweede voorbeeld uit een paper die het nut van dependent types goed uitlegt
\ref{TPoP}, laat zien dat dependent types zeer expressief zijn. In Haskell is
het bijvoorbeeld onmogelijk een veilige en volledige interface te voorzien naar
een relationele database die niet steunt op preprocessing of experimentele
features.

%----------------------------------------%
\begin{minted}[fontsize=\small]{agda}
  data RA : Schema → Set where
    Read    : ∀ {s} → Handle s → RA s
    Union   : ∀ {s} → RA s → RA s → RA s
    Diff    : ∀ {s} → RA s → RA s → RA s
    Product : ∀ {s s'} → {_ : So (disjoint s s')} → RA s → RA s'
              → RA (append s s')
    Project : ∀ {s} → (s' : Schema) → {_ : So (sub s' s)}
              → RA s → RA s'
    Select  : ∀ {s} → Expr s BOOL → RA s → RA s
\end{minted}

TODO: uitleg bij dit voorbeeld.
